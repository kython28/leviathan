from typing import (
    TypeVar,
    TypeVarTuple,
    Callable,
    Self,
    Optional,
    Unpack,
    Coroutine,
    Any,
    TextIO,
    AsyncGenerator,
)
from _typeshed import FileDescriptorLike
from contextvars import Context
from types import FrameType
import asyncio, weakref

_T = TypeVar("_T")

class Future(asyncio.Future[_T]):
    def __init__(self, loop: asyncio.AbstractEventLoop) -> None: ...
    def result(self) -> _T: ...
    def set_result(self, value: _T) -> None: ...
    def exception(self) -> Optional[BaseException]: ...
    def set_exception(self, exception: type | BaseException) -> None: ...
    def done(self) -> bool: ...
    def cancel(self, msg: Optional[str] = None) -> bool: ...
    def cancelled(self) -> bool: ...
    def add_done_callback(
        self, callback: Callable[[Self], object], *, context: Optional[Context] = None
    ) -> None: ...
    def remove_done_callback(self, callback: Callable[[Self], object]) -> int: ...
    def get_loop(self) -> asyncio.AbstractEventLoop: ...

class Task(asyncio.Task[_T]):
    def __init__(
        self,
        coro: Coroutine[Any, Any, _T],
        loop: asyncio.AbstractEventLoop,
        *,
        name: Optional[str] = None,
        context: Optional[Context] = None,
    ) -> None: ...
    def uncancel(self) -> int: ...
    def cancelling(self) -> bool: ...
    def get_coro(self) -> Coroutine[Any, Any, _T]: ...
    def get_context(self) -> Context: ...
    def get_name(self) -> str: ...
    def set_name(self, name: Any) -> None: ...
    def get_stack(self, *, limit: Optional[int] = None) -> list[FrameType]: ...
    def print_stack(
        self, *, limit: Optional[int] = None, file: Optional[TextIO] = None
    ) -> None: ...

_Ts = TypeVarTuple("_Ts")

class Loop(asyncio.AbstractEventLoop):  # type: ignore
    _asyncgens: weakref.WeakSet[AsyncGenerator[Any]]

    def __init__(
        self,
        ready_tasks_queue_min_bytes_capacity: int,
        exception_handler: Callable[[Exception], None],
    ) -> None: ...
    def run_forever(self) -> None: ...
    def stop(self) -> None: ...
    def is_running(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def close(self) -> None: ...
    def create_task(
        self,
        coro: Coroutine[Any, Any, _T],
        *,
        name: str | None = ...,
        context: Context | None = ...,
    ) -> Task[_T]: ...
    def create_future(self) -> Future[Any]: ...
    def time(self) -> float: ...
    def call_soon(
        self,
        callback: Callable[[Unpack[_Ts]], object],
        *args: Unpack[_Ts],
        context: Context | None = ...,
    ) -> asyncio.Handle: ...
    def call_soon_threadsafe(
        self,
        callback: Callable[[Unpack[_Ts]], object],
        *args: Unpack[_Ts],
        context: Context | None = ...,
    ) -> asyncio.Handle: ...
    def call_at(
        self,
        when: float,
        callback: Callable[[Unpack[_Ts]], object],
        *args: Unpack[_Ts],
        context: Context | None = ...,
    ) -> asyncio.TimerHandle: ...
    def call_later(
        self,
        delay: float,
        callback: Callable[[Unpack[_Ts]], object],
        *args: Unpack[_Ts],
        context: Context | None = ...,
    ) -> asyncio.TimerHandle: ...
    def add_signal_handler(
        self, sig: int, callback: Callable[[Unpack[_Ts]], object], *args: Unpack[_Ts]
    ) -> None: ...
    def remove_signal_handler(self, sig: int) -> bool: ...
    def add_reader(
        self,
        fd: FileDescriptorLike,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
    ) -> None: ...
    def remove_reader(self, fd: FileDescriptorLike) -> bool: ...
    def add_writer(
        self,
        fd: FileDescriptorLike,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
    ) -> None: ...
    def remove_writer(self, fd: FileDescriptorLike) -> bool: ...
